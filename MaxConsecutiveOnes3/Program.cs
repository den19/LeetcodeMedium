namespace MaxConsecutiveOnes3
{
    /*
    Нужно пройти по массиву nums и найти максимальную длину подмассива, содержащего не более k нулей.
    Мы можем использовать два указателя для отслеживания текущей длины окна и количества нулей внутри этого окна. 

    Объяснение алгоритма

    Инициализация: Начальные значения указателей left и right, а также счётчика нулей zeroCount.
    Проход по массиву:
        Каждый раз, когда мы встречаем ноль, увеличиваем счётчик zeroCount.
        Если количество нулей превышает допустимое значение k, то сдвигаем левую границу окна (left) до тех пор, пока количество нулей снова не станет меньше или равно k.
        После каждого шага обновляется максимальная длина подмассива, который содержит не более k нулей.
    Результат: В конце возвращается максимальная длина подмассива.

    Сложность

    Время: O(n), где nn — длина массива. Мы проходим по каждому элементу массива ровно один раз.
    Память: O(1) — используем фиксированное количество переменных для хранения состояния.
     */
    internal class Program
    {
        static void Main(string[] args)
        {
            int[] nums = { 1, 1, 0, 1, 1, 0, 1 };
            int k = 2;

            Console.WriteLine(MaxConsecutiveOnes(nums, k));
        }


        public static int MaxConsecutiveOnes(int[] nums, int k)
        {
            int n = nums.Length;

            // Указатели начала и конца окна
            int left = 0, right = 0;

            // Количество нулей в текущем окне
            int zeroCount = 0;

            // Максимальная длина последовательности единиц
            int maxLength = 0;

            while (right < n)
            {
                // Если текущий элемент равен нулю, увеличиваем счетчик нулей
                if (nums[right] == 0)
                {
                    zeroCount++;
                }

                // Пока количество нулей больше допустимого, сдвигаем левую границу окна
                while (zeroCount > k)
                {
                    if (nums[left] == 0)
                    {
                        zeroCount--;
                    }
                    left++;
                }

                // Обновляем максимальную длину
                maxLength = Math.Max(maxLength, right - left + 1);

                // Сдвигаем правую границу окна
                right++;
            }

            return maxLength; 
        }
    }
}
